# 프로그래밍과 데이터 in Python
# 2. for 반복문
# 06. 피타고라스 삼조

# 참고

# '피타고라스 정리' -> '피타고라스 삼조'라는 개념
# 참고 URL - https://projecteuler.net/problem=9

# 실습 설명
# '피타고라스 정리'라고 들어 보셨나요?
# 직각삼각형에서, 빗변의 제곱이 두 직각변의 제곱의 합과 같다는 정리입니다.
# 거기서 나온 '피타고라스 삼조'라는 개념이 있는데요.
# 피타고라스 삼조란, 피타고라스 정리(a ** 2 + b ** 2 == c ** 2)를 만족하는
# 세 자연수 쌍 (a, b, c) 입니다.

# 예를 들어, 3 ** 2 + 4 ** 2 == 5 ** 2이기 때문에 (3, 4, 5)는 피타고라스 삼조입니다.

# a < b < c 라고 가정할 때,
# a + b + c = 400 을 만족하는 피타고라스 삼조 (a, b, c)는 단 하나인데요.
# 이 경우, a ∗ b ∗ c 는 얼마인가요?

# 문제 출처: Project Euler Problem 9
# '피타고라스 정리' -> '피타고라스 삼조'라는 개념
# 참고 URL - https://projecteuler.net/problem=9

# 실습 결과
# 2040000
# 수강 편의를 위해 a + b + c = 1000이었던 문제 조건을 a + b + c = 400으로 바꾸었습니다.
# 참고하세요!

# 힌트 1 - 가장 단순하게 코드를 짜면 이렇습니다.
#         for a in range(1, 400):
#             for b in range(1, 400):
#                 for c in range(1, 400):
#                     if a * a + b * b == c * c and a < b < c and a + b + c == 400:
#                         print(a * b * c)
#         이 코드를 막상 실행해 보면, 굉장히 오랜 시간이 걸릴 것입니다.
#         논리적으로 봤을 때는 정답을 찾아 주는 코드입니다.
#         하지만 너무 오래 걸려서 사실상 사용할 수 없다고 보시면 되는데요.
#         이런 걸 "비효율적인 알고리즘"이라고 합니다.

#         알고리즘이 비효율적인 이유를 간단히만 설명드리겠습니다.

#         a가 가능한 경우는 1``부터399``까지,
#         b가 가능한 경우는 1부터 399까지,
#         c가 가능한 경우는 1부터 399까지인데요.
#         그러면,
#         if a * a + b * b == c * c and a &lt; b &lt; c and a + b + c == 400:
#             print(a * b * c)
#         위 코드가 총 63,521,199번 실행됩니다. 6천만 번 이상 실행되는 거죠.

#         더 효율적인 코드를 짜기 위해서 for문을 두 개만 쓰세요.

# 힌트 2 - 우리는 a + b + c = 400 이라는 조건을 지켜야 합니다.
#         그말인즉슨 c = 400 − a − b
#         라는 거죠. 이 점을 잘 활용해 보세요.

# 실습 해설

# 해설
# 가장 단순한 방식
# 가장 단순하게 코드를 짜면 이렇습니다.

for a in range(1, 400):
    for b in range(1, 400):
        for c in range(1, 400):
            if a * a +  b * b == c * c and a < b < c and a + b + c == 400:
                print(a * b * c)

# 이 코드를 막상 실행해 보면, 꽤 오랜 시간이 걸릴 것입니다.
# 논리적으로 봤을 때 언젠가는 올바른 정답을 찾아 주는 코드입니다.
# 하지만 400 대신 더 큰 숫자가 들어갈 수도 있는 걸 감안하면,
# 너무 오래 걸려서 사실상 사용할 수 없다고 보시면 되는데요.
# 이런 걸 '비효율적인 알고리즘'이라고 합니다.

# 알고리즘이 비효율적인 이유를 간단히만 설명드리겠습니다.

# a가 가능한 경우는 1부터 399까지,
# b가 가능한 경우는 1부터 399까지,
# c가 가능한 경우는 1부터 399까지인데요.
# 그러면,

if a * a + b * b == c * c and a < b < c and a + b + c == 400:
    print(a * b * c)

# 위 코드가 총 63,521,199번 실행됩니다.
# 6천만 번 이상 실행되는 거죠.

# 효율적인 방식
# 우리는 a + b + c = 400 이라는 조건을 지켜야 합니다.
# 그말인즉슨 c = 400 − a − b
# 라는 거죠. 이 점을 잘 활용하면 더 효율적인 코드를 작성할 수 있습니다.

# 모범 답안
for a in range(1, 400):
    for b in range(1, 400):
        c = 400 - a - b
        if a * a + b * b == c * c and a < b < c:
            print(a * b * c)

# 이렇게 하면 정답인 2040000를 구할 수 있습니다.

# 코드
# 여기에 코드를 작성하세요

# for a in range(401):
#     for b in range(401):
#         for c in range(401):
#             if (b > a and b < c) and (400 == a + b + c) and (c ** 2 == a ** 2 + b ** 2):
#                 print(a * b * c)

for a in range(1, 400):
    for b in range(1, 400):
        c = 400 - a - b  # a와 b의 값만 구할 수 있다면 c라는 값 또한 구할 수 있음.
        if (b > a and b < c) and (c ** 2 == a ** 2 + b ** 2):
            print(a * b * c)